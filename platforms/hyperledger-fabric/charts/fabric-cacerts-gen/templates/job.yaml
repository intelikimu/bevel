---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "fabric-cacerts-gen.name" . }}-init
  labels:
    app: {{ .Release.Name }}
    app.kubernetes.io/name: fabric-cacerts-gen-job
    app.kubernetes.io/component: fabric-cacerts-gen-job
    app.kubernetes.io/part-of: {{ include "fabric-cacerts-gen.fullname" . }}
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    app.kubernetes.io/managed-by: helm
  namespace: {{ .Release.Namespace }}
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}
        app.kubernetes.io/name: fabric-cacerts-gen-job
        app.kubernetes.io/component: cacerts-gen-job
        app.kubernetes.io/part-of: {{ include "fabric-cacerts-gen.fullname" . }}
        app.kubernetes.io/namespace: {{ .Release.Namespace }}
        app.kubernetes.io/managed-by: helm
    spec:
      serviceAccountName: {{ .Values.global.serviceAccountName }}
      restartPolicy: OnFailure
      imagePullSecrets:
      {{- if .Values.image.pullSecret }}
        - name: {{ .Values.image.pullSecret }}
      {{- end }}
      volumes:
      - name: scripts-volume
        configMap:
          name: bevel-vault-script
      - name: package-manager
        configMap:
          name: package-manager
      - name: openssl-config
        configMap:
          name: openssl-config-file
          defaultMode: 0775
          items:
            - key: openssl.conf
              path: openssl.conf
      containers:
        - name:  "cacerts"
          image: {{ $.Values.image.alpineUtils }}
          imagePullPolicy: IfNotPresent
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.global.vault.address }}
          - name: VAULT_APP_ROLE
            value: {{ $.Values.global.vault.role }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ $.Values.global.vault.authPath }}
          - name: VAULT_SECRET_ENGINE
            value: "{{ .Values.global.vault.secretEngine }}"
          - name: VAULT_SECRET_PREFIX
            value: "{{ .Values.global.vault.secretPrefix }}"
          - name: VAULT_TYPE
            value: "{{ $.Values.global.vault.type }}"
          - name: COMPONENT_NAME
            value: {{ .Release.Namespace }}
          - name: ORG_NAME
            value: {{ $.Values.ca.orgName }}
          - name: CA_URL
            value: {{ .Release.Name }}.{{ .Release.Namespace }}
          - name: CA_SUBJECT
            value: "{{ $.Values.ca.subject }}/CN={{ .Release.Name }}.{{ .Release.Namespace }}"
          command: ["sh", "-c"]
          args:
            - |-
              . /scripts/package-manager.sh
              # Define the packages to install
              packages_to_install="jq curl openssl kubectl"
              install_packages "$packages_to_install"

              formatCertificate () {
                NAME="${1##*/}"
                while IFS= read -r line
                do
                  echo "$line\n"
                done < ${1} > ${2}/${NAME}.txt
              }

{{- if eq .Values.global.vault.type "hashicorp" }}
              . /scripts/bevel-vault.sh
              echo "Getting vault Token..."
              vaultBevelFunc "init"
              #Read if genesis exists in Vault
              vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/ca"
              function safeWriteSecret {
                key=$1
                FORMAT_CERTIFICATE_PATH="/formatcertificate"
                mkdir -p ${FORMAT_CERTIFICATE_PATH}
                formatCertificate "${COMPONENT_NAME}-CA.key" "${FORMAT_CERTIFICATE_PATH}"
                formatCertificate "ca.${COMPONENT_NAME}-cert.pem" "${FORMAT_CERTIFICATE_PATH}"

                PEM_CERTIFICATE=$(cat ${FORMAT_CERTIFICATE_PATH}/ca.${COMPONENT_NAME}-cert.pem.txt)
                KEY_CERTIFICATE=$(cat ${FORMAT_CERTIFICATE_PATH}/${COMPONENT_NAME}-CA.key.txt)

                # create a JSON file for the data related to node crypto 
                echo "
                  {
                    \"data\": 
                      {
                        \"ca.${COMPONENT_NAME}-cert.pem\": \"${PEM_CERTIFICATE}\",
                        \"${COMPONENT_NAME}-CA.key\": \"${KEY_CERTIFICATE}\"
                      }  
                  }" > payload.json

                # Calling a function to write secrets to the vault.
                vaultBevelFunc 'write' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/${key}" 'payload.json'
                rm payload.json
              }
              
{{- else }}
              function safeWriteSecret {
                key=$1
                kubectl get secret ${key}-certs --namespace ${COMPONENT_NAME} -o json > /dev/null 2>&1
                if [ $? -ne 0 ]; then
                  kubectl create secret generic ${key}-certs --namespace ${COMPONENT_NAME} --from-file=ca-${COMPONENT_NAME}-key=${COMPONENT_NAME}-CA.key \
                    --from-file=ca-${COMPONENT_NAME}-cert=ca.${COMPONENT_NAME}-cert.pem
                fi
              }
{{- end }}

              if [ "$SECRETS_AVAILABLE" == "yes" ]
              then
                  echo "The certificates are already created, skipping..."
              else  

                # this commands generate the CA certificate
                openssl ecparam -name prime256v1 -genkey -noout -out  ${COMPONENT_NAME}-CA.key
                openssl req -x509 -config "/openssl/openssl.conf" -new -nodes -key ${COMPONENT_NAME}-CA.key -days 1024 -out ca.${COMPONENT_NAME}-cert.pem -extensions v3_req -subj "${CA_SUBJECT}" -addext "subjectAltName = DNS:${CA_URL}"

                safeWriteSecret ca

              fi

{{- if eq .Values.global.vault.type "hashicorp" }}
              vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/credentials"
              function safeWriteCredentials {
                key=$1
                echo "
                {
                  \"data\": 
                  {
                    \"user\": \"${ORG_NAME}-adminpw\"
                  }
                }" > payload.json

                # Calling a function to write a secret to the vault.
                vaultBevelFunc 'write' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/${key}" 'payload.json'
                # Calling a function to retrieve secrets from Vault only if they exist.
                vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/${key}"
              }
{{- else }}                
              function safeWriteCredentials {
                key=$1
                kubectl get secret ca-${key} --namespace ${COMPONENT_NAME} -o json > /dev/null 2>&1
                if [ $? -ne 0 ]; then
                  kubectl create secret generic ca-${key} --namespace ${COMPONENT_NAME} --from-literal=user="${ORG_NAME}-adminpw"
                fi
              }
{{- end }}

              if [ "$SECRETS_AVAILABLE" == "yes" ]
              then
                echo "The credentials are already created, skipping..."
              else
                safeWriteCredentials credentials
              fi
          volumeMounts:
          - name: scripts-volume
            mountPath: /scripts/bevel-vault.sh
            subPath: bevel-vault.sh
          - name: package-manager
            mountPath: /scripts/package-manager.sh
            subPath: package-manager.sh
          - name: openssl-config
            mountPath: /openssl/openssl.conf
            subPath: openssl.conf
